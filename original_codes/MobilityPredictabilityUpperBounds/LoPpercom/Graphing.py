'''
Created on 30 Sep 2013

@author: Gavin Smith
@organization: Horizon Digital Economy Institute, The University of Nottingham.

@copyright: This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

from __future__ import division
import numpy as np
import pylab as pl


# These are hard-coded labels and correspond to hard-coded array in other parts of the code.

listRealSpatialRes = ['$618m^{2}$\n($35m$)','$2474m^{2}$\n($70m$)','$9896m^{2}$\n($141m$)',
                      '$39586m^{2}$\n($281m$)','$158347m^{2}$\n($563m$)','$633388m^{2}$\n($1.1km$)',
                      '$2.53km^{2}$\n($2.3km$)','$10.13km^{2}$\n($4.5km$)','$40.54km^{2}$\n($9km$)']
         
listTemporalRes = ['0:05:00','0:10:00','0:15:00','0:30:00','0:45:00','1:00:00']

def plot_map( LoP, LoPB, num_ppl, output_path_and_filename, diff_map ):
    """
    Plots an individual heatmap
    
    :param LoP: Mean Upper bound on predictability 2D array (spatiotemporal quantisation grid)
    :type LoP: 2D array of reals
    :param LoPB: Number of people for which the predictability was not able to be computed, 2D spatiotemporal grid
    :type LoPB: 2D array of ints
    :param num_ppl: Total number of people meant to have an upper bound computed for
    :type num_ppl: int
    :param output_path_and_filename: Output file
    :type output_path_and_filename: str
    :param diff_map: 0: data is for the difference, 1: data is for the refined method, 2: data is for the original method
    :type diff_map: int
    """
    # 0 = diff
    # 1 = RL
    # 2 = DL
    
    # We use a different scale for the colours in the case of the difference map
    if diff_map == 0:
        scale = [0.0*100,0.4*100,0.05*100]
    else:
        scale = [0.0*100,1*100,0.05*100]
    
    # to percent for viewing
    LoP = np.array(LoP)*100
    
    f = pl.figure()    
    ax = f.add_subplot(111)

        
    pl.pcolor(LoP,vmin=scale[0], vmax=scale[1])
    for y in range(LoP.shape[0]):
        for x in range(LoP.shape[1]):
            if LoPB[y,x] != 0:
                txt = '{:2.2f}\n({})'.format(LoP[y, x], int(num_ppl-LoPB[y,x]))
            else:
                txt = '{:2.2f}'.format(LoP[y, x])
            pl.text(x + 0.5, y + 0.5, txt, horizontalalignment='center', verticalalignment='center')
            
    v = np.arange(scale[0], scale[1]+0.01, scale[2])
    pl.colorbar(ticks=v)
    tx = [0,1,1,2,2,3,3,4,4,5,5,6]

    ty = np.asarray([4,4,5,5,6,6,7,7,7,7,8,8])
    pl.fill_between(tx, ty,ty, linewidth = 5)
   
        
    pl.xticks(np.arange(LoP.shape[1])+0.5)
    pl.yticks(np.arange(LoP.shape[0])+0.5)
    pl.ylabel("Spatial Resolution (max. straight line distance across region)")
    ax.set_yticklabels(listRealSpatialRes)
    ax.set_xticklabels(listTemporalRes,rotation=20)
    pl.xlabel('Temporal Resolution (hour:min:sec)')
    
    # 0 = diff
    # 1 = RL
    # 2 = DL
    if diff_map == 0:
        pl.title('Reduction in upper bound achieved (difference in Mean predictability (%))\n({} people unless otherwise noted within a cell in brackets)'.format(num_ppl))
    elif diff_map == 1:
        pl.title('Mean potential predictability (%) via refined method (this work)\n({} people unless otherwise noted within a cell in brackets)'.format(num_ppl))
    elif diff_map == 2:
        pl.title('Mean potential predictability (%) via original method\n({} people unless otherwise noted within a cell in brackets)'.format(num_ppl))
    
    f.savefig(output_path_and_filename[:-4] + ".pdf", filetype='pdf', bbox_inches='tight')


    

if __name__ == '__main__':
    """
    Loads the data generated by GeolifeEntropyCalc.py and produces three heatmaps.
    1. The upper bounds on predictability using the original method
    2. The upper bounds on predictability using the refined method
    3. A heatmap of the difference in predictability between the original and refined methods.
    """
    
    output_dir = './ResultsLoP_replication/final_graphs'
    groupName = 'PERCOM'
    
    
    fileNa = '{}/Heatmap_Grp{}RL.csv'.format(output_dir,groupName)
    fileBa = '{}/Heatmap_Grp{}_failed_ct.csv'.format(output_dir,groupName)
    LoPa = np.genfromtxt(fileNa,skip_header=0)  
    LoPBa = np.genfromtxt(fileBa,skip_header=0)  
    output_path_and_filename = '{}/Heatmap_RL42.csv'.format(output_dir)
    plot_map(LoPa, LoPBa, 42,output_path_and_filename, diff_map = 1)
    
    
    fileNb = '{}/Heatmap_Grp{}DL.csv'.format(output_dir,groupName)
    fileBb = '{}/Heatmap_Grp{}_failed_ct.csv'.format(output_dir,groupName)
    LoPb = np.genfromtxt(fileNb,skip_header=0)  
    LoPBb = np.genfromtxt(fileBb,skip_header=0)  
    output_path_and_filename = '{}/Heatmap_DL42.csv'.format(output_dir)
    plot_map(LoPb, LoPBb, 42,output_path_and_filename, diff_map = 2)
    
    
    output_path_and_filename = '{}/Heatmap_DL42mRL42.csv'.format(output_dir)

    plot_map(LoPb-LoPa, LoPBb, 42,output_path_and_filename, diff_map = 0)
    

    
    